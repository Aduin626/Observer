# Паттерны проектирования Observer примерами на C#

В данном репозитории содержатся реализации паттерна Observer на языке программирования C#. Ниже вы можете ознакомиться с описанием паттерна, его назначением, а также преимуществами и недостатками. <br />
После изучения теории можете переходить в код - он хорошо задокументирован, поэтому разобраться в нем не составит труда. <br />
Помимо документации в данном файле будет пошагово описана реализация каждого примера паттерна, который есть в репозитории.

### В папке каждого паттерна содержатся: <br />

- его реализация в библиотеке классов; <br />
- демонстрация работы в консольном приложении; <br />
- тестирование методов классов и проверка корректности реализации паттерна <br />

## Оглавление

1. [Определение и способы реализации паттерна наблюдатель (Observer)](#Наблюдатель)
2. [Реализация с помощью интерфейсов ](#реализация-с-помощью-интерфейсов)
3. [Реализация с помощью делегатов ](#реализация-с-помощью-делегатов)
4. [Реализация с помощью событий ](#реализация-с-помощью-событий)
5. [Достоинства и недостатки паттерна Observer ](#достоинства-и-недостатки-паттерна-observer)

### Наблюдатель

**Наблюдатель (Observer)** - поведенческий шаблон проектирования. Определяет зависимость типа «один ко многим» таким образом, что при изменении объекта все, зависящие от него, получают сообщение об этом событии. <br>
В dotnet есть три способа реализации данного паттерна:<br><br>
:one: **Через делегаты.** Данный способ гарантирует наличие наблюдателя и подходит, когда нужно реализовать отношение: 1 поставщик – 1 наблюдатель. Также при данном подходе можно получить результат – ответ от подписчика.<br>
:two: **Через события.** Любое число подписчиков. Нет гарантии наличия подписчиков. Не предусмотрено получение ответа от подписчика.<br>
:three: **Через набор интерфейсов IObserver** (механизм для получения push-уведомлений)/IObservable (определяет поставщика push-уведомлений).<br>

:x: Почему стоит использовать эти интерфейсы вместо событий: события плохо поддаются тестированию, данный паттерн универсален, он может использоваться и в других языках программирования. В C# есть события, а в других языках программирования их может и не быть.
:grey_exclamation: Таким образом, у нас есть **IObservable** – определяет наблюдаемый объект и **IObserver** – определяет наблюдателей.<br><br>

### Реализация с помощью интерфейсов

Реализуем паттерн **наблюдатель** на примере **Портала для отображения акций фондовой бирже**. У нас будут пользователи портала - инвесторы биржи. <br>
Инвесторы могут подписываться на уведомления о изменениях цен акций тех бирж в которые они инвестировали, уведомления будут публиковаться на портале.<br>
Соответственно, все пользователи, которые подписаны на уведомления портала (подписчики) будут уведомлены об изменениях цен. В данном случае корпоративный портал будет **поставщиком данных** для наших подписчиков. <br><br>
:one: Создаем интерфейс IObservable, который используется объектом(фондовой биржей). Он содержит методы для добавления и удаления наблюдателей

```C#
    public interface IObservable
    {
        void AddObserver(IObserver observer);
        void RemoveObserver(IObserver observer);
        void NotifyObservers();
    }
```

:two: Теперь мы создаем интерфейс IObserver, который будет использоваться наблюдателями(инвесторами). Он содержит метод для обновления информации о изменении цены

```C#
    public interface IObserver
    {
        void Update(double price, string burse);
    }
```

:three: Далее мы создаем Stock класс для фондовой биржи, который реализовывает интерфейс IObservable

```C#
        //В этом классе мы храним список наблюдателей и информацию о текущей цене.
        //Методы AddObserver, RemoveObserver и NotifyObservers соответствуют методам, определенным в интерфейсе IObservable.
        //Метод UpdatePrice используется для обновления информации о цене и вызывает метод NotifyObservers для оповещения наблюдателей.
        public class Stock : IObservable
        {
            private List<IObserver> observers = new List<IObserver>();
            private double price;
            public string burse { get; private set; }

            public Stock(double price, string burse)
            {
                this.price = price;
                this.burse = burse;
            }

            public void AddObserver(IObserver observer)
            {
                observers.Add(observer);
            }
            public void RemoveObserver(IObserver observer)
            {
                observers.Remove(observer);
            }
            public void NotifyObservers()
            {
                foreach (IObserver observer in observers)
                {
                    observer.Update(price, burse);
                }
            }

            public void UpdatePrice(double newPrice)
            {
                price = newPrice;
                NotifyObservers();
            }

        }

```

:four: Теперь давайте создадим класс Investor, реализующий метод IObserver

```C#
    public class Investor : IObserver
    {
        //В этом классе мы храним имя инвестора и реализуем метод Update для обновления информации о цене.
        private string name;

        public Investor(string name)
        {
            this.name = name;
        }


        public void Update(double price, string burse)
        {
            Console.WriteLine($"Цена акций биржи {burse} была изменена на {price} для {name}");

        }
    }
```

:five: И наконец запустим данный проект в консольном приложении

```C#
   internal class Program
    {
        static void Main(string[] args)
        {
            // Создаем объект фондовой биржи
            Stock stock = new Stock(200, "DDF");
            //Создаем объекты наблюдателей
            Investor investor1 = new Investor("Иван");
            Investor investor2 = new Investor("Вика");
            //Добавляем к объекту двух наблюдателей
            stock.AddObserver(investor1);
            stock.AddObserver(investor2);

            stock.UpdatePrice(1032.0);
            stock.UpdatePrice(232);
            stock.UpdatePrice(9323);

            Console.ReadLine();

        }
    }
```

Отписка у нас происходит следующим образом: мы удаляем подписчика из нашей коллекции подписчиков, соответственно, ему больше не будут приходить уведомления с портала.<br><br>

:white_check_mark:**Преимущества**
Гибкость: использование интерфейсов предоставляет очень гибкий механизм для реализации паттерна "наблюдатель", поскольку объекты-наблюдатели могут быть любым типом, который реализует нужный интерфейс.
Расширяемость: интерфейсы могут быть расширены и переопределены, что позволяет легко расширять функциональность объектов-субъектов и объектов-наблюдателей.
:x:**Недостатки**
Сложность реализации: использование интерфейсов может быть более сложным, чем использование делегатов и событий, поскольку требуется настройка более сложной структуры классов.
Излишняя обобщенность: использование интерфейсов может привести к излишней обобщенности кода и к более сложной логике.

Далее будут показаны примеры реализации того же функционала, но только с помощью делегатов и событий

### Реализация с помощью делегатов

Еще один из способов реализации паттерна "наблюдатель" заключается в использовании делегатов. Этот подход позволяет объекту-субъекту иметь коллекцию делегатов, каждый из которых представляет собой подписчика на конкретное событие.

Так как выше уже был представлен пример работы с данным примером, некоторые детали будут опущены

:one: Создадим класс Stock, который представляет акции на фондовой бирже

```C#

    public class Stock
    {

        private readonly string _symbol; //символ акции на бирже(частный, только для чтения);
        private double _price; //текущая цена акции (частная переменная).

        public Stock(string symbol, double price)
        {

            _symbol = symbol;
            _price = price;
        }

        //Свойство Price предоставляет доступ к переменной _price.
        //Когда значение _price изменяется, вызывается метод Notify().
        public double Price
        {
            get { return _price; }
            set
            {
                if (_price != value)
                {
                    _price = value;
                    Notify();
                }
            }
        }

        //Событие PriceChanged создается c использованием делегата Action<double, string>,
        //который принимает два параметра: новую цену(double) и символ акции(string).
        public event Action<double, string> PriceChanged;


        //Метод Notify() вызывает событие PriceChanged,
        //которое проксирует параметры _price и _symbol к подписанным методам-обработчикам.
        private void Notify()
        {
            PriceChanged?.Invoke(_price, _symbol);
        }

    }
```

:two: Запустим данный проект в консольном приложении

```C#
    internal class Program
    {
        static void Main(string[] args)
        {
            //Метод который выводит информацию о том что цена акций изменилась
            void OnPriceChanged(double price , string symbol)
            {
                Console.WriteLine($"Цена акций биржи {symbol} изменена: {price}");
            }

            //Объект stock со значениями акций и начальной ценой 100
            var stock = new Stock("AABL", 100.0);

            //Обработчик событий OnPriceChanged подписывается на событие PriceChanged объекта stock.
            stock.PriceChanged += new Action<double,string>(OnPriceChanged);

            stock.Price = 107.0;

            Console.ReadLine();
        }
    }
```

В случае необходимости можно отписаться от события PriceChanged с помощью той же конструкции только с использование -=

:white_check_mark: **Преимущества**
Простота реализации: использование делегатов очень просто и интуитивно понятно, поэтому этот подход может быть особенно полезен для небольших проектов, где не требуется слишком сложная логика.
Быстрота работы: использование делегатов может дать небольшой прирост в производительности, поскольку при вызове события не требуется проходить через сложную цепочку связанных объектов.
:x:**Недостатки**
Ограниченность: делегаты могут использоваться только для событий, которые имеют тип делегата. Если требуется реализовать более сложную логику, возможно, потребуется использовать другой подход.
Проверка типов: использование делегатов требует, чтобы типы делегатов были известны в момент компиляции, что означает, что проверка типов может привести к ошибкам.

### Реализация с помощью событий

Другой подход к реализации паттерна "наблюдатель" заключается в использовании событий. Событие - это специальный вид делегата, который позволяет вызывать методы, когда происходит определенное событие.

:one: Создадим класс Observer, который служит для отслеживания изменений в объектах типа Stock

```C#
    public class Observer
    {

        // Метод OnPriceChanged вызывается при изменении цены акции
        // sender: объект, вызывающий событие (в данном случае объект типа Stock)
        // args: аргументы события
        public void OnPriceChanged(object sender, EventArgs args)
        {
            // Проверяем, является ли отправитель события объектом класса Stock
            if (sender is Stock stock)
            {
                // Выводим информацию об изменении цены акции на экран
                Console.WriteLine($"Предприятие {stock._symbol} цена акций изменена на {stock.Price}");
            }
        }

    }
```

:two: Создадим класс Observable, назначение которого быть основой для объектов, которые нуждаются в оповещении других объектов об изменении свойства "Price"

```C#
    public class Observable
    {
        // Событие для оповещения подписчиков об изменении свойства "Price"
        public event EventHandler PriceChanged;
        // Защищенный метод, оповещающий всех подписчиков об изменении свойства "Price"
        protected void Notify()
        {
            // Проверка на наличие подписчиков
            if (PriceChanged != null)
            {
                // Оповещение всех подписчиков об изменении свойства "Price"
                PriceChanged(this, EventArgs.Empty);
            }
        }
    }
```

:three: Потом создадим класс Stock (наследует класс Observable) , который предоставляет методы для добавления, удаления и оповещения наблюдателей.

```C#
 public class Stock : Observable
    {
        private double _price;        // Поле для хранения цены акции.

        // Свойство Symbol только для чтения. Внешние пользователи этого класса не могут изменить символ акции после его создания;
        // символ акции можно установить только при инициализации экземпляра класса.
        public string _symbol { get; private set; }


        // Свойство Price содержит методы get и set для чтения и изменения цены акции соответственно.
        public double Price
        {
            get { return _price; }
            set
            {
                // При изменении значения цены акции вызывается метод Notify(),
                // который оповещает всех наблюдателей об изменении цены.
                _price = value;
                Notify();
            }
        }



        // Конструктор класса Stock, принимающий символ и начальную цену акции.
        public Stock(string symbol, double price)
        {
            _symbol = symbol;
            _price = price;
        }
    }
```

:four: И наконец создадим запустим проект в консоли

```C#

    internal class Program
    {
        static void Main(string[] args)
        {

            //Создание двух объектов класса 'Stock' с разными исходными значениями стоимости акций
            Stock logi = new Stock("LOGI", 102);
            Stock fohj = new Stock("FOHJ", 120);
            //Создание объекта-наблюдателя
            Observer observer = new Observer();
            //Регистрация наблюдателя для события 'PriceChanged' каждого объекта 'Stock'
            logi.PriceChanged += observer.OnPriceChanged;
            fohj.PriceChanged += observer.OnPriceChanged;

            logi.Price = 2324;
            fohj.Price = 501;

            Console.ReadLine();
        }
    }
```

:white_check_mark:**Преимущества**
Надежность: использование событий может быть более надежным, поскольку оно предоставляет более явный механизм для регистрации и удаления подписчиков.
Расширяемость: события могут быть переопределены в производных классах, что позволяет расширять функциональность объектов-субъектов.
:x:**Недостатки**
Низкая производительность: при вызове событий происходит обращение к механизму делегатов, что может вызывать дополнительные задержки.
Сложность использования: для работы с событиями необходимо иметь хорошее понимание механизмов делегатов и событий.

### Достоинства и недостатки паттерна Observer

:white_check_mark: **Преимущества паттерна Observer**: Можно создавать новые классы подписчиков. При этот класс наблюдаемого объекта как-то изменять не нужно.<br>
:x: **Недостатки**: Подписчики уведомляются в произвольном порядке.
